
# Function to calculate the magnitude of an error vector
def vector_magnitude(vec):
    return (vec[0] ** 2 + vec[1] ** 2 + vec[2] ** 2) ** 0.5


# Create a list to hold the results for DataFrame
results = []
pt_markers = [marker for marker in chunk.markers if marker.label.startswith("PT")]
output_folder = 'C:/Users/matan.yuval/Desktop/pointonMeshFinal_Trial/FinalForLabelbox/'
chunk_label = Metashape.app.document.chunk.label
doc_path = Metashape.app.document.path
# Extract the project name from the document path
project_name = os.path.splitext(os.path.basename(doc_path))[0]  # Remove file extension
os.makedirs(output_folder, exist_ok=True)
# Create a combined variable with project name and chunk label
combined_name = f"{project_name}_{chunk_label}"
output_folder = os.path.join(output_folder, combined_name)
os.makedirs(output_folder, exist_ok=True)
# Iterate over each marker in the chunk
for marker in pt_markers:
    errs = []  # Reset errors for each marker
    camera_indices = []  # Reset camera indices for each marker
    coords_list = []  # To hold the projected coordinates

    if not len(marker.projections.keys()) and not marker.position:
        continue

    # Iterate through each camera in the chunk
    for camera_index, camera in enumerate(chunk.cameras):
        if camera in marker.projections.keys():
            x, y, z = marker.projections[camera].coord
            if marker.projections[camera].pinned:
                print(marker.label, camera.label, "pinned", x, y)
            else:
                print(marker.label, camera.label, "unpinned", x, y)
        else:
            if not marker.position:
                continue
            if not camera.transform:
                continue

            point = marker.position

            if camera.project(point):
                x, y = camera.project(point)
                if (camera.sensor.width / 8 <= x < camera.sensor.width / 8 * 7) and \
                        (camera.sensor.height / 8 <= y < camera.sensor.height / 8 * 7):

                    coords_2D = camera.project(point)
                    point_internal = chunk.model.pickPoint(camera.center, camera.unproject(coords_2D))

                    if point_internal is not None:
                        # Transform the internal point to world coordinates
                        point3D_world = chunk.crs.project(chunk.transform.matrix.mulp(point_internal))
                        err = marker.reference.location - point3D_world
                        errs.append(err)
                        camera_indices.append((camera_index, camera.label))  # Store tuple (index, label)
                        coords_list.append(coords_2D)  # Save the projected coordinates

    # After processing all cameras, create KDTree for the found camera indices
    # If there were errors, process them
    if errs:
        magnitudes = [vector_magnitude(err) for err in errs]
        error_info = [(magnitudes[i], errs[i], camera_indices[i], coords_list[i]) for i in range(len(magnitudes))]

        # Sort by magnitude to get the smallest errors
        error_info.sort(key=lambda x: x[0])  # Sort by magnitude

        # Save only the two smallest errors for the current marker
        for min_error in error_info[:1]:
            # Convert coordinates to integers
            coords_int = (int(min_error[3][0]), int(min_error[3][1]))
            camera_index, camera_label = min_error[2]  # Unpack the tuple
            marker_position_chunk_coords = chunk.transform.matrix.mulp(marker.position)
            results.append((marker.label, camera_index, camera_label, coords_int, marker_position_chunk_coords))

# Create DataFrame with an additional column for Camera Label
results_df = pd.DataFrame(results, columns=['Marker Label', 'Camera Index', 'Camera Label', 'Projected 2D Coordinates','marker_position_chunk_coords'])
os.makedirs(output_folder, exist_ok=True)
results_df_path = os.path.join(output_folder, "results_df.txt")
results_df.to_csv(results_df_path, index=False, header=True)
# print(results_df)


import os
import Metashape
import cv2
import numpy as np

combined_output_folder_path = os.path.join(output_folder, 'combined_images')
os.makedirs(combined_output_folder_path, exist_ok=True)

# Create a list to store saved image paths
saved_image_paths = []
WIDTH = 1600

# Get the active chunk
chunk = Metashape.app.document.chunk
region = chunk.region

# Iterate through the results DataFrame
for index, row in results_df.iterrows():
    camera_index = row['Camera Index']
    coords = row['Projected 2D Coordinates']  # This is a tuple (x, y)
    x, y = coords  # Unpack the coordinates
    marker_name = row['Marker Label']

    # Load the corresponding camera
    camera = chunk.cameras[camera_index]
    image_path = camera.photo.path  # Get the image path
    #print(f"Loading image from path: {image_path}")
    image = cv2.imread(image_path)  # Read the image using OpenCV

    # Check if the image was loaded successfully
    if image is None:
        print(f"Error loading image: {image_path}. Skipping this marker.")
        continue

    old_x, old_y = coords  # Original projected coordinates

    # Get camera sensor dimensions
    sensor_width = camera.sensor.width
    sensor_height = camera.sensor.height

    if camera.orientation == 6:  # 90 degrees clockwise
        new_x, new_y = sensor_height - old_y, old_x
    elif camera.orientation == 8:  # 270 degrees clockwise
        new_x, new_y = old_y, sensor_width - old_x
    else:  # For other orientations (e.g., 1 for no rotation)
        new_x = old_x
        new_y = old_y

    # Specify the crop size
    crop_size = 2000  # Size of the crop

    # Calculate the crop boundaries
    x_start = max(0, new_x - crop_size // 2)
    y_start = max(0, new_y - crop_size // 2)
    x_end = min(image.shape[1], new_x + crop_size // 2)
    y_end = min(image.shape[0], new_y + crop_size // 2)

    # Crop the image
    cropped_image = image[y_start:y_end, x_start:x_end]
    point_x = new_x - x_start
    point_y = new_y - y_start
    cv2.circle(cropped_image, (point_x, point_y), radius=10, color=(0, 0, 255), thickness=5)

    # Create a filename using the camera label and coordinates
    camera_label = camera.label  # Assuming the camera has a label attribute
    filename = f"{marker_name}_{camera_label}_x{new_x}_y{new_y}.png"
    output_path = os.path.join(output_folder, filename)

    # Save the cropped image
    cv2.imwrite(output_path, cropped_image)
    saved_image_paths.append((marker_name, camera_label, output_path))  # Store saved path
    #print(f"Saved subimage: {output_path}")

    marker = [marker for marker in chunk.markers if marker.label == marker_name][0]
    target_marker = marker.position  # Get the position of the marker
    location = target_marker + region.rot * Metashape.Vector(
        [0, 0, 0.1 * region.size.z])  # Camera location above the target
    R = chunk.transform.rotation.t() * Metashape.Matrix().Diag([1, -1, -1])  # Rotation matrix

    # Create the camera transformation matrix
    cameraT = Metashape.Matrix().Translation(location) * Metashape.Matrix().Rotation(R)

    # Calibration for rendering
    calibration = Metashape.Calibration()
    calibration.width = WIDTH
    #calibration.height = 0.15 * region.size.z
    calibration.height = int(WIDTH / region.size.x * region.size.y)
    calibration.f = WIDTH // 2

    # Render the image
    rendered_image = chunk.model.renderImage(cameraT, calibration)

    # Save the rendered image
    image_filename = f"render_{marker.label}_2.png"  # Name based on the marker label
    rendered_image_path = os.path.join(output_folder, image_filename)
    rendered_image.save(rendered_image_path)

    # Read the image back using OpenCV
    image_np = cv2.imread(rendered_image_path)
    os.remove(rendered_image_path)

    # Project the target_marker to 2D coordinates
    marker_4d = Metashape.Vector([target_marker[0], target_marker[1], target_marker[2], 1])
    marker_in_camera_space = cameraT.inv() * marker_4d
    marker_in_camera_space_3d = Metashape.Vector(
        [marker_in_camera_space[0], marker_in_camera_space[1], marker_in_camera_space[2]])
    projected_coords = calibration.project(marker_in_camera_space_3d)

    # Convert the projected coordinates to integers for drawing
    point_x = int(projected_coords[0])
    point_y = int(projected_coords[1])

    # Mark the projected point on the image
    cv2.circle(image_np, (point_x, point_y), radius=10, color=(0, 0, 255), thickness=-1)

    filename = f"{marker_name}_3DModel_{combined_name}.png"
    output_with_marker_path = os.path.join(output_folder, filename)
    cv2.imwrite(output_with_marker_path, image_np)
    #print(f"Images saved for marker: {marker_name}")
    if len(saved_image_paths) > 0:
        img2 = image_np
        img1 = cropped_image

        # Check if both images were loaded
        if img1 is None:
            print(f"Error loading image: {img1_path}. Skipping this pair.")
        elif img2 is None:
            print(f"Error loading image: {img2_path}. Skipping this pair.")
        else:
            # Ensure both images have the same height for proper concatenation
            if img1.shape[0] != img2.shape[0]:
                #img2 = cv2.resize(img2, (img2.shape[1], img1.shape[0]))
                img1 = cv2.resize(img1, (img2.shape[1], img2.shape[0]))

            # Create a black line (vertical) between the images
            line_height = img1.shape[0]
            line_width = 5  # Width of the line
            black_line = np.zeros((line_height, line_width, 3), dtype=np.uint8)

            # Combine images and the black line
            combined_image = np.hstack((img1, black_line, img2))

            # Create a filename for the combined image
            combined_filename = f"{marker.label}_{camera_label}_{combined_name}.png"
            combined_output_path = os.path.join(combined_output_folder_path, combined_filename)
            cv2.imwrite(combined_output_path, combined_image)
            #print(f"Combined image saved: {combined_output_path}")



import os
import cv2

# Define the folder path
folder_path = combined_output_folder_path
resize_folder_path = os.path.join(folder_path, 'resize')

# Create the resize folder if it doesn't exist
os.makedirs(resize_folder_path, exist_ok=True)

# Define the new width
new_width = 1600  # Set your desired width

# Iterate through all files in the folder
for filename in os.listdir(folder_path):
    if filename.endswith(('.png', '.jpg', '.jpeg')):  # Check for image files
        image_path = os.path.join(folder_path, filename)

        # Read the image
        image = cv2.imread(image_path)

        # Check if the image was loaded successfully
        if image is not None:
            # Get the original dimensions
            original_height, original_width = image.shape[:2]

            # Calculate the new height to maintain aspect ratio
            aspect_ratio = original_width / original_height
            new_height = int(new_width / aspect_ratio)

            # Resize the image
            resized_image = cv2.resize(image, (new_width, new_height))

            # Create a new filename for the resized image
            new_filename = f"{os.path.splitext(filename)[0]}_resize{os.path.splitext(filename)[1]}"
            resized_image_path = os.path.join(resize_folder_path, new_filename)

            # Save the resized image
            cv2.imwrite(resized_image_path, resized_image)
            #print(f"Resized and saved: {new_filename}")







import os
import pandas as pd
import Metashape
import open3d as o3d
import os
import Metashape
import cv2
import numpy as np
import pandas as pd

output_folder = 'C:/Users/matan.yuval/Desktop/pointonMeshFinal_Trial/'
# Get the document path
doc_path = Metashape.app.document.path
# Get the chunk label
chunk_label = Metashape.app.document.chunk.label

# Extract the project name from the document path
project_name = os.path.splitext(os.path.basename(doc_path))[0]  # Remove file extension

# Create a combined variable with project name and chunk label
combined_name = f"{project_name}_{chunk_label}"

# Output the results
print("Project Name:", project_name)
print("Chunk Label:", chunk_label)
print("Combined Name:", combined_name)
###STEP1 Generate 100 points on mesh
import open3d as o3d
import numpy as np
import pandas as pd
from sklearn.neighbors import KDTree

chunk = Metashape.app.document.chunk

# Step2: find images and 3d view, save to folder
import pandas as pd
from scipy.spatial import KDTree
import numpy as np


# Function to calculate the magnitude of an error vector
def vector_magnitude(vec):
    return (vec[0] ** 2 + vec[1] ** 2 + vec[2] ** 2) ** 0.5


# Create a list to hold the results for DataFrame
results = []
pt_markers = [marker for marker in chunk.markers if marker.label.startswith("PT")]
pt_markers = pt_markers[1:3]
output_folder = 'C:/Users/matan.yuval/Desktop/FinalExperiment2/'
chunk_label = Metashape.app.document.chunk.label
doc_path = Metashape.app.document.path
# Extract the project name from the document path
project_name = os.path.splitext(os.path.basename(doc_path))[0]  # Remove file extension
os.makedirs(output_folder, exist_ok=True)
# Create a combined variable with project name and chunk label
combined_name = f"{project_name}_{chunk_label}"
output_folder = os.path.join(output_folder, combined_name)
os.makedirs(output_folder, exist_ok=True)
# Iterate over each marker in the chunk
for marker in pt_markers:
    errs = []  # Reset errors for each marker
    camera_indices = []  # Reset camera indices for each marker
    coords_list = []  # To hold the projected coordinates

    if not len(marker.projections.keys()) and not marker.position:
        continue

    # Iterate through each camera in the chunk
    for camera_index, camera in enumerate(chunk.cameras):
        if camera in marker.projections.keys():
            x, y, z = marker.projections[camera].coord
            if marker.projections[camera].pinned:
                print(marker.label, camera.label, "pinned", x, y)
            else:
                print(marker.label, camera.label, "unpinned", x, y)
        else:
            if not marker.position:
                continue
            if not camera.transform:
                continue

            point = marker.position

            if camera.project(point):
                x, y = camera.project(point)
                if (camera.sensor.width / 8 <= x < camera.sensor.width / 8 * 7) and \
                        (camera.sensor.height / 8 <= y < camera.sensor.height / 8 * 7):

                    coords_2D = camera.project(point)
                    point_internal = chunk.model.pickPoint(camera.center, camera.unproject(coords_2D))

                    if point_internal is not None:
                        # Transform the internal point to world coordinates
                        point3D_world = chunk.crs.project(chunk.transform.matrix.mulp(point_internal))
                        err = marker.reference.location - point3D_world
                        errs.append(err)
                        camera_indices.append((camera_index, camera.label))  # Store tuple (index, label)
                        coords_list.append(coords_2D)  # Save the projected coordinates

    # After processing all cameras, create KDTree for the found camera indices
    # If there were errors, process them
    if errs:
        magnitudes = [vector_magnitude(err) for err in errs]
        error_info = [(magnitudes[i], errs[i], camera_indices[i], coords_list[i]) for i in range(len(magnitudes))]

        # Sort by magnitude to get the smallest errors
        error_info.sort(key=lambda x: x[0])  # Sort by magnitude

        # Save only the two smallest errors for the current marker
        for min_error in error_info[:1]:
            # Convert coordinates to integers
            coords_int = (int(min_error[3][0]), int(min_error[3][1]))
            camera_index, camera_label = min_error[2]  # Unpack the tuple
            marker_position_chunk_coords = chunk.transform.matrix.mulp(marker.position)
            results.append((marker.label, camera_index, camera_label, coords_int, marker_position_chunk_coords))

# Create DataFrame with an additional column for Camera Label
results_df = pd.DataFrame(results, columns=['Marker Label', 'Camera Index', 'Camera Label', 'Projected 2D Coordinates',
                                            'marker_position_chunk_coords'])
os.makedirs(output_folder, exist_ok=True)
results_df_path = os.path.join(output_folder, "results_df.txt")
results_df.to_csv(results_df_path, index=False, header=True)
# print(results_df)


import os
import Metashape
import cv2
import numpy as np

combined_output_folder_path = os.path.join(output_folder, 'combined_images')
os.makedirs(combined_output_folder_path, exist_ok=True)

# Create a list to store saved image paths
saved_image_paths = []
WIDTH = 1600

# Get the active chunk
chunk = Metashape.app.document.chunk
region = chunk.region

# Iterate through the results DataFrame
for index, row in results_df.iterrows():
    camera_index = row['Camera Index']
    coords = row['Projected 2D Coordinates']  # This is a tuple (x, y)
    x, y = coords  # Unpack the coordinates
    marker_name = row['Marker Label']

    # Load the corresponding camera
    camera = chunk.cameras[camera_index]
    image_path = camera.photo.path  # Get the image path
    # print(f"Loading image from path: {image_path}")
    image = cv2.imread(image_path)  # Read the image using OpenCV

    # Check if the image was loaded successfully
    if image is None:
        print(f"Error loading image: {image_path}. Skipping this marker.")
        continue

    old_x, old_y = coords  # Original projected coordinates

    # Get camera sensor dimensions
    sensor_width = camera.sensor.width
    sensor_height = camera.sensor.height

    if camera.orientation == 6:  # 90 degrees clockwise
        new_x, new_y = sensor_height - old_y, old_x
    elif camera.orientation == 8:  # 270 degrees clockwise
        new_x, new_y = old_y, sensor_width - old_x
    else:  # For other orientations (e.g., 1 for no rotation)
        new_x = old_x
        new_y = old_y

    # Specify the crop size
    crop_size = 1600  # Size of the crop

    # Calculate the crop boundaries
    x_start = max(0, new_x - crop_size // 2)
    y_start = max(0, new_y - crop_size // 2)
    x_end = min(image.shape[1], new_x + crop_size // 2)
    y_end = min(image.shape[0], new_y + crop_size // 2)

    # Crop the image
    cropped_image = image[y_start:y_end, x_start:x_end]
    point_x = new_x - x_start
    point_y = new_y - y_start
    cv2.circle(cropped_image, (point_x, point_y), radius=10, color=(0, 0, 255), thickness=5)

    # Create a filename using the camera label and coordinates
    camera_label = camera.label  # Assuming the camera has a label attribute
    filename = f"{marker_name}_{camera_label}_x{new_x}_y{new_y}.png"
    output_path = os.path.join(output_folder, filename)

    # Save the cropped image
    cv2.imwrite(output_path, cropped_image)
    saved_image_paths.append((marker_name, camera_label, output_path))  # Store saved path
    # print(f"Saved subimage: {output_path}")

    marker = [marker for marker in chunk.markers if marker.label == marker_name][0]
    target_marker = marker.position  # Get the position of the marker
    Metashape.app.model_view.viewpoint.coo = marker.reference.location

    # Set magnification (zoom level)
    Metashape.app.model_view.viewpoint.mag = 1000

    rendered_image = Metashape.app.model_view.captureView(1600, 1600)

    # Save the rendered image
    image_filename = f"render_{marker.label}_2.png"  # Name based on the marker label
    rendered_image_path = os.path.join(output_folder, image_filename)
    rendered_image.save(rendered_image_path)

    # Read the image back using OpenCV
    image_np = cv2.imread(rendered_image_path)
    os.remove(rendered_image_path)
    projected_coords = [800, 800]

    # Convert the projected coordinates to integers for drawing
    point_x = int(projected_coords[0])
    point_y = int(projected_coords[1])

    # Mark the projected point on the image
    cv2.circle(image_np, (point_x, point_y), radius=10, color=(0, 0, 255), thickness=-1)

    filename = f"{marker_name}_3DModel_{combined_name}.png"
    output_with_marker_path = os.path.join(output_folder, filename)
    cv2.imwrite(output_with_marker_path, image_np)
    # print(f"Images saved for marker: {marker_name}")
    if len(saved_image_paths) > 0:
        img2 = image_np
        img1 = cropped_image

        # Check if both images were loaded
        if img1 is None:
            print(f"Error loading image: {img1_path}. Skipping this pair.")
        elif img2 is None:
            print(f"Error loading image: {img2_path}. Skipping this pair.")
        else:
            # Ensure both images have the same height for proper concatenation
            if img1.shape[0] != img2.shape[0]:
                img2 = cv2.resize(img2, (img2.shape[1], img1.shape[0]))

            # Create a black line (vertical) between the images
            line_height = img1.shape[0]
            line_width = 5  # Width of the line
            black_line = np.zeros((line_height, line_width, 3), dtype=np.uint8)

            # Combine images and the black line
            combined_image = np.hstack((img1, black_line, img2))

            # Create a filename for the combined image
            combined_filename = f"{marker.label}_{camera_label}_{combined_name}.png"
            combined_output_path = os.path.join(combined_output_folder_path, combined_filename)
            cv2.imwrite(combined_output_path, combined_image)
            # print(f"Combined image saved: {combined_output_path}")

import os
import cv2

# Define the folder path
folder_path = combined_output_folder_path
resize_folder_path = os.path.join(folder_path, 'resize')

# Create the resize folder if it doesn't exist
os.makedirs(resize_folder_path, exist_ok=True)

# Define the new width
new_width = 1600  # Set your desired width

# Iterate through all files in the folder
for filename in os.listdir(folder_path):
    if filename.endswith(('.png', '.jpg', '.jpeg')):  # Check for image files
        image_path = os.path.join(folder_path, filename)

        # Read the image
        image = cv2.imread(image_path)

        # Check if the image was loaded successfully
        if image is not None:
            # Get the original dimensions
            original_height, original_width = image.shape[:2]

            # Calculate the new height to maintain aspect ratio
            aspect_ratio = original_width / original_height
            new_height = int(new_width / aspect_ratio)

            # Resize the image
            resized_image = cv2.resize(image, (new_width, new_height))

            # Create a new filename for the resized image
            new_filename = f"{os.path.splitext(filename)[0]}_resize{os.path.splitext(filename)[1]}"
            resized_image_path = os.path.join(resize_folder_path, new_filename)

            # Save the resized image
            cv2.imwrite(resized_image_path, resized_image)
            # print(f"Resized and saved: {new_filename}")
